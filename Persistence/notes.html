<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Persistence using File and DB</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #F4F4F4;
            color: #333;
        }
        h1, h2 {
            color: #2C3E50;
        }
        pre {
            background-color: #EAEAEA;
            padding: 10px;
            border-left: 5px solid #3498DB;
            overflow-x: auto;
        }
        footer {
            margin-top: 20px;
            font-size: 0.9em;
            color: #777;
        }
    </style>
</head>
<body>
    <h1>Persistence using File and DB</h1>

    <h2>Where I Struggled</h2>
    <p>
        Understanding different serialization formats and handling complex object relationships was tricky.  
        Managing database transactions and ensuring consistency in SQLAlchemy took time.
    </p>

    <h2>Breaking the Problem Down</h2>
    <p>
        I split the problem into two main sections:
        <ul>
            <li><strong>File-based Persistence:</strong> Pickle, JSON, YAML for object serialization.</li>
            <li><strong>Database Persistence:</strong> SQLite and SQLAlchemy with Pydantic models.</li>
        </ul>
    </p>

    <h2>File-based Persistence</h2>
    <ul>
        <li><strong>Pickle Serialization:</strong> Saved and loaded a <code>Person</code> object.</li>
        <li><strong>JSON Serialization:</strong> Converted a <code>Book</code> object to and from JSON.</li>
        <li><strong>YAML Serialization:</strong> Serialized a <code>Car</code> object with PyYAML.</li>
        <li><strong>Handling Complex Objects:</strong> Custom serialization for a <code>Graph</code> class.</li>
        <li><strong>Skipping Sensitive Data:</strong> Ensured passwords were excluded in <code>User</code> serialization.</li>
        <li><strong>Versioning Objects:</strong> Managed backward compatibility in deserialization.</li>
        <li><strong>Cyclic References:</strong> Handled objects referencing each other.</li>
    </ul>

    <h2>Database Persistence</h2>
    <ul>
        <li><strong>SQLite with SQLAlchemy:</strong> Defined models, created tables, and performed CRUD operations.</li>
        <li><strong>Using Pydantic:</strong> Validated data before inserting into the database.</li>
        <li><strong>Transactional Operations:</strong> Ensured atomicity with commit and rollback handling.</li>
    </ul>

    <h2>What Went Surprisingly Well</h2>
    <p>
        JSON and YAML were straightforward, and using Pydantic with SQLAlchemy made validation seamless.  
        Managing transactions with SQLAlchemy sessions turned out to be easier than expected.
    </p>

    <h2>Key Learnings</h2>
    <p>
        - Pickle is useful but not human-readable or secure.<br>
        - JSON is the best balance of readability and flexibility.<br>
        - SQLAlchemy simplifies database operations but requires careful session management.<br>
    </p>

    <h2>What AI Helped Me</h2>
    <p>
        Debugging serialization issues, handling SQLAlchemy ORM errors, and optimizing database queries.
    </p>

    <footer>
        <p>Note: This document is based on my experience working with persistence in Python.</p>
    </footer>
</body>
</html>
